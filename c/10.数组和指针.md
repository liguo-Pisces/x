# 数组和指针

## 数组

数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。

要访问数组中的元素，通过使用数组下标数（也称为索引）表示数组中的各元素。

### 初始化数组

标量变量（scalar variable）

用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。

有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用const声明和初始化数组。

使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，读者运行该程序后的输出会与该示例不同。

C Primer Plus P279

初始化列表中的项数应与数组的大小一致。

当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。

### 指定初始化器（C99）

C99新增了一个新特性：指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。

### 给数组元素赋值

声明数组后，可以借助数组下标（或索引）给数组元素赋值。

C不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。

### 数组边界

在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。

编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。

C信任程序员的原则。

数组元素的编号从0开始。最好是在声明数组时使用符号常量来表示数组的大小。

### 指定数组的大小

在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。sizeof表达式被视为整型常量，但是（与C++不同）const值不是。另外，表达式的值必须大于0。

```c
float a8[n]; // C99之前不允许
float a9[m]; // C99之前不允许
```

以前支持C90标准的编译器不允许后两种声明方式。而C99标准允许这样声明，这创建了一种新型数组，称为变长数组（variable-length array）或简称VLA（C11放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性）。

C99引入变长数组主要是为了让C成为更好的数值计算语言。

## 多维数组

主数组（master array）

初始化二维数组是建立在初始化一维数组的基础上的。

初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。

### 其他多维数组

二维数组的相关内容都适用于三维数组或更多维的数组。

可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。

## 指针和数组

指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。

数组名是数组首元素的地址。

如果`flizny`是一个数组，`flizny`和`&flizny[0]`都表示数组首元素的内存地址（&是地址运算符）。两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给指针变量，然后可以修改指针变量的值。

地址是十六进制的。

在系统中，地址按字节编址，short类型占用2字节，double类型占用8字节。在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则就无法正确地取回地址上的值）。

* 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如double类型的变量）通常是该对象第一个字节的地址。
* 在指针前面使用\*运算符可以得到该指针所指向对象的值。
* 指针加1，指针的值递增它所指向类型的大小（以字节为单位）。

数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。

指针表示法和数组表示法是两种等效的方法。

## 函数、数组和指针

声明数组形参

因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把`int ar[]`和`int * ar`解释成一样。也就是说，`ar`是指向`int`的指针。由于函数原型可以省略参数名，所以下面4种原型都是等价的：

```c
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```

但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：

```c
int sum(int *ar, int n) {}
int sum(int ar[], int n) {}
```

可以使用以上提到的任意一种函数原型和函数定义。

### 使用指针形参

函数要处理数组必须知道何时开始、何时结束。使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）。但是这并不是给函数传递必备信息的唯一方法。还有另一种方法是传递两个指针，第一个指针指明数组的开始处（与前面用法相同），第二个指针指明数组的结尾处。

C保证在各数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。C Primer Plus P294

C保证了marbles + SIZE有效，但是对marbles[SIZE]（即储存在该位置上的值）未作任何保证，所以程序不能访问该位置。

### 指针表示法和数组表示法

处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用函数表示法还是指针表示法。

至于C语言，`ar[i]`和`*(ar + i)`这两个表达式都是等价的。无论`ar`是数组名还是指针变量，这两个边大师都没问题。但是，只有当`ar`是指针变量时，才能使用`ar++`这样的表达式。

指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主要任务时确保代码正确、逻辑清晰，而代码优化应该留给编译器去做。

## 指针操作

指针变量的基本操作。

* 赋值：可以把地址赋给指针。
* 解引用：\*运算符给出指针指向地址上储存的值。
* 取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，&运算符给出指针本身的地址。
* 指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。
* 递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。
* 指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第一个运算对象，整数是第二个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。
* 递减指针：当然，出了递增指针还可以递减指针。
* 指针求差：可以计算两个指针的差集。通常，求差集的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。
* 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。

注意，这里的减法有两种。可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。

在递增或递减时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C只能保证指向数组任意元素的指针和指向数组后面第一个位置的指针是有效。但是，如果递增或递减一个指针后超出了这个范围，则是未定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置是有效的，也能解引用这样的越界指针。

说道注意事项，一定要牢记一点：千万不要解引用未初始化的指针。切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。

## 保护数组中的数据

### 对形式参数使用const

在K&R C的年代，避免类似错误的唯一方法是提高警惕。ANSI C提供了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。

使用const并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。这样使用const可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。一般而言，入股哦便携的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。

### const的其他内容

虽然用`#define`指令可以创建类似功能的符号常量，但是const的用法更加灵活。可以创建const数组、const指针和指向const的指针。

指向const的指针通常用于函数形参中，表明该函数不会使用指针改变数据。

关于指针赋值和const需要注意一些规则。首先，把const数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的。然而，只能把非const数据的地址赋给普通指针。

const还有其他的用法。可以声明并初始化一个不能指向别处的指针，关键是const的位置 ，可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。

在创建指针时还可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值。

## 指针和多维数组 ！！！

假设有下面的声明：

`int zippo[4][2];`

然后数组名`zippo`是该数组首元素的地址。在本例中，`zippo`的首元素是一个内含两个int值的数组，所以zippo是这个内含两个int值的数组的地址。

* 因为`zippo`是数组首元素的地址，所以`zippo`的值和`&zippo[0]`的值相同。而`zippo[0]`本身是一个内含两个整数的数组，所以`zippo[0]`的值和它首元素（一个整数）的地址（即`&zippo[0][0]`）相同。简而言之，`zippo[0]`是一个占用一个int大小对象的地址，而`zippo`是一个占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以`zippp`和`zippo[0]`的值相同。
* 给指针或地址加1，其值会增加对对应类型大小的数值。在这方面，`zippo`和`zippo[0]`不同，因为`zippo`指向的对象占用了两个int大小，而`zippo[0]`指向的对象只占用一个int大小。因此，`zippo + 1`和`zippo[0] + 1`的值不同。
* 解引用一个指针（在指针前使用\*运算符）或在数组名后使用带下标的\[\]运算符，得到引用对象代表的值。因为`zippo[0]`是该数组首元素（`zippo[0][0]`）的地址，所以`*(zippo[0])`表示储存在`zippo[0][0]`上的值（即一个int类型的值）。与此类似，`*zippo`代表该数组首元素（`zippo[0]`）的值，但是`zippo[0]`本身是一个int类型值的地址。该值的地址是`&zippo[0][0]`，所以`*zippo`就是`&zippo[0][0]`。对两个表达式应用解引用运算符表明，`**zippo`与`*&zippo[0][0]`等价，这相当于`zippo[0][0]`，即一个int类型的值。简而言之，`zippo`是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是双重间接（double indirection）的例子。

### 指向多维数组的指针 ！！！

如何声明一个指针变量`pz`指向一个二维数组（如，`zippo`）？在编写处理类似`zippo`这样的二维数组时会用到这样的指针。把指针声明为指向int的类型还不够。因为指针int只能与`zippo[0]`的类型匹配，说明该指针指向一个int类型的值。但是`zippo`是它首元素的地址，该元素是一个内含两个int类型值的一维数组。因此，`pz`必须指向一个内含两个int类型值的数组，而不是指向一个int类型的值，其声明如下：

`int (*pz)[2]; // pz指向一个内含两个int类型值的数组`

以上代码把`pz`声明为指向一个数组的指针，该数组内含两个int类型值。为什么要在声明中使用圆括号？因为\[\]的优先级高于\*。

`int *pax[2] // pax是一个内含连个指针元素的数组，每个元素都指向int的指针`

由于\[\]优先级高，先与`pax`结合，所以`pax`成为一个内含两个元素的数组。然后\*表示`pax`数组内含两个指针。最后，int表示`pax`数组中的指针都指向int类型的值。因此，这行代码声明了两个指向int的指针。而前面有圆括号的版本，\*先与`pz`结合，因此声明的是一个指向数组（内含两个int类型的值）的指针 。

可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名。

```c
zippo[m][n] = *(*(zippo + m) + n);
pz[m][n] = *(*(pz + m) + n);
```

### 指针的兼容性

指针之间的赋值比数值类型之间的赋值要严格。

C Primer Plus P305

C和C++中的const的用法很相似，但是并不完全相同。区别之一是，C++允许在声明数组大小时使用const整数，而C却不允许。区别之二是，C++的指针赋值检查更严格：

```c
const int y;
const int *p2 = &y;
int *p1;
p1 = p2;	// C++中不允许这样，但是C可能只给出警告
```

C++不允许把const指针赋给非const指针。而C则允许这样做，但是如果通过p1更改y，其行为是未定义的。

### 函数和多维数组

如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参。在函数挺中，通常使用数组表示法进行相关操作。

```c
void somefunction(int (*pt)[4]);
void somefunction(int pt[][4]);
```

一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值：

`int sum4d(int ar[][12][20][30], int rows);`

因为第一对方括号只用于表示这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。下面的声明与该声明等价：

`int sum4d(int (*ar)[12][20][30], int rows); // ar是一个指针`

这里，ar指向一个12x20x30的int数组。

与使用typedef相比，这种方式方便得多：

```c
typedef int arr4[4];  // arr4是一个内含4个int的数组
typedef arr4 arr3x4[3];  // arr3x4是一个内含3个arr4的数组
int sum2(arr3x4 ar, int rows);  // 与下面的声明相同
int sum2(int ar[3][4], int rows);  // 与下面的声明相同
int sum2(int ar[][4], int rows);  // 标准形式
```

## 变长数组（VLA）

C规定，数组的维度必须是常量，不能用变量来代替COLS。

C99新增了变长数组（variable-length array，VLA），允许使用变量表示数组的维度。

前面提到过，变长数组由一些限制。变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用`static`或`extern`存储类别说明符。而且，不能再声明中初始化它们。最终，C11把变长数组作为一个可选特性，而不是必须强制实现的特性。

变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。

C99/C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：

`int sum2d(int, int, int ar[*][*]); // ar是一个变长数组（VLA），省略了维度形参名`

需要注意的是，在函数定义的形参列表中声明的变长数组并未实际创建数组。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以次改传入的数组。

C90标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合，如20、sizeof表达式或其他不适const的内容。由于C实现可以扩大整型常量表达式的范围，所以可能会允许使用const，但是这种代码可能无法移植。

C99/C11标准允许在声明变长数组时使用const变量。所以该数组的定义必须是声明在块中的自动存储类别数组。

变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通C数组都是静态内存分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译器在编译时就知道了。

## 复合字面量

在C99标准以前，对于带数组形参的函数，情况不同，可以传递数组，但是没有等价的数组常量。C99新增了复合字面量（compound literal）。字面量是除符号常量外的常量。

对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。

`(int [2]){10, 20} // 复合字面量`

初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：

`(int []){50, 20, 90} // 内含3个元素的复合字面量`

因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。

与有数组名的数组类似，复合字面量的类型名也代表首元素的地址。

可以把复合字面量作为实际参数传递给带有匹配形式参数的函数。

记住，复合字面量是提供只临时需要的值的一种手段。复合字面量具有块作用域，这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最内层的花括号中。

## 关键概念

数组用于储存形同类型的数据。C把数组看作是派生类型，因为数组是建立在其他类型的基础上的。也就是说，无法简单地声明一个数组。在声明数组时必须说明其元素的类型。所谓的其他类型也可以是数组类型，这种情况下，创建的是数组的数组（或称为二维数组）。

通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题，有助于实现程序的模块化。在把数组名作为实际参数时，传递给函数的不是整个数组，而是数组的地址（因此，函数对应的形式参数是指针）。为了处理数组，函数必须知道从何处开始读取数据和要处理多少个数组元素。数组地址提供了“地址”，“元素个数”可以内置在函数中或作为单独的参数传递。第二种方法更普遍，因为这样做可以让同一个函数处理不同大小的数组。

数组和指针的关系密切，通一个操作可以用数组表示法或指针表示法。它们之间的关系允许你在处理数组的函数中使用数组表示法，即使函数的形式参数是一个指针，而不是数组。

对于传统的C数组，必须用常量表达式指明数组的大小，所以数组大小在编译时就已确定。C99/C11新增了变长数组，可以用变量表示数组大小。这意味着变长数组的大小延迟到程序运行时才确定。

## 本章小结

数组是一组数据类型相同的元素。数组元素按顺序储存在内存中，通过整数下标（或索引）可以访问各元素。在C中，数组首元素的下标是0，所以对于内含n个元素的数组，其最后一个元素的小标是n-1。作为程序员，要确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效性。

声明一个简单的一维数组形式如下：

`type name[size];`

这列，type是数组中每个元素的数据类型，name是数组名，size是数组元素的个数。对于传统的C数组，要求size是整型常量表达式。但是C99/C11允许使用整型非常量表达式。这种情况下的数组被称为变长数组。

C把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组首元素的指针等价。概括地说，数组和指针的关系十分密切。如果ar是一个数组，那么表达式ar[i]和*(ar + i)等价。

对于C语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字const。在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。

指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改变。也就是说，如果pd指向一个数组的8字节double类型值，那么pd加1意味着其值加8，以便它指向该数组的下一个元素。

二维数组即是数组的数组。例如，下面声明了一个二维数组：

`double sales[5][12];`

该数组名为sales，有5个元素（一维数组），每个元素是一个内含12个double类型值的数组。第1个一维数组是sales[0]，第2个一维数组是sales[1]，以此类推，每个元素都是内含12个double类型值的数组。使用第2个下标可以访问这些一维数组中的特定元素。例如，sales\[2\]\[5\]是sales[2]的第6个元素，而sales[2]是sales的第3个元素。

C语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类型匹配的指针形参。声明这样的指针形参要指定所有的数组维度，除了第1维度。传递的第1维度通常作为第2个参数。例如，为了处理前面声明的sales数组，函数原型和函数调用如下：

`void display(double ar[][12], int rows);`

`display(sales, 5);`

变长数组提供第2中语法，把数组维度作为参数传递。在这种情况下，对应函数原型和函数调用如下：

`void display(int rows, int cols, double ar[rows][cols]);`

`display(5, 12, sales);`

虽然上述讨论中使用的是int类型的数组和double类型的数组，其他类型的数组也是如此。然而，字符串有一些特殊的规则，真是由于其末尾的空字符导致。有了这个空字符，不用传递数组的大小，函数通过检测字符串的末尾也知道在何处停止。