# 数组和指针

## 数组

数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。

要访问数组中的元素，通过使用数组下标数（也称为索引）表示数组中的各元素。

### 初始化数组

标量变量（scalar variable）

用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。

有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用const声明和初始化数组。

使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，读者运行该程序后的输出会与该示例不同。

C Primer Plus P279

初始化列表中的项数应与数组的大小一致。

当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。

### 指定初始化器（C99）

C99新增了一个新特性：指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。

### 给数组元素赋值

声明数组后，可以借助数组下标（或索引）给数组元素赋值。

C不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。

### 数组边界

在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。

编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。

C信任程序员的原则。

数组元素的编号从0开始。最好是在声明数组时使用符号常量来表示数组的大小。

### 指定数组的大小

在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。sizeof表达式被视为整型常量，但是（与C++不同）const值不是。另外，表达式的值必须大于0。

```c
float a8[n]; // C99之前不允许
float a9[m]; // C99之前不允许
```

以前支持C90标准的编译器不允许后两种声明方式。而C99标准允许这样声明，这创建了一种新型数组，称为变长数组（variable-length array）或简称VLA（C11放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性）。

C99引入变长数组主要是为了让C成为更好的数值计算语言。

## 多维数组

主数组（master array）

初始化二维数组是建立在初始化一维数组的基础上的。

初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。

### 其他多维数组

二维数组的相关内容都适用于三维数组或更多维的数组。

可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。

## 指针和数组

指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。

数组名是数组首元素的地址。

如果`flizny`是一个数组，`flizny`和`&flizny[0]`都表示数组首元素的内存地址（&是地址运算符）。两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给指针变量，然后可以修改指针变量的值。

地址是十六进制的。

在系统中，地址按字节编址，short类型占用2字节，double类型占用8字节。在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则就无法正确地取回地址上的值）。

* 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如double类型的变量）通常是该对象第一个字节的地址。
* 在指针前面使用\*运算符可以得到该指针所指向对象的值。
* 指针加1，指针的值递增它所指向类型的大小（以字节为单位）。

数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。

指针表示法和数组表示法是两种等效的方法。

## 函数、数组和指针

声明数组形参

因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把`int ar[]`和`int * ar`解释成一样。也就是说，`ar`是指向`int`的指针。由于函数原型可以省略参数名，所以下面4种原型都是等价的：

```c
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```

但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：

```c
int sum(int *ar, int n) {}
int sum(int ar[], int n) {}
```

可以使用以上提到的任意一种函数原型和函数定义。

### 使用指针形参

函数要处理数组必须知道何时开始、何时结束。使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）。但是这并不是给函数传递必备信息的唯一方法。还有另一种方法是传递两个指针，第一个指针指明数组的开始处（与前面用法相同），第二个指针指明数组的结尾处。

C保证在各数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。C Primer Plus P294

C保证了marbles + SIZE有效，但是对marbles[SIZE]（即储存在该位置上的值）未作任何保证，所以程序不能访问该位置。

### 指针表示法和数组表示法

处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用函数表示法还是指针表示法。

至于C语言，`ar[i]`和`*(ar + i)`这两个表达式都是等价的。无论`ar`是数组名还是指针变量，这两个边大师都没问题。但是，只有当`ar`是指针变量时，才能使用`ar++`这样的表达式。

指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主要任务时确保代码正确、逻辑清晰，而代码优化应该留给编译器去做。

## 指针操作

指针变量的基本操作。

* 赋值：可以把地址赋给指针。
* 解引用：\*运算符给出指针指向地址上储存的值。
* 取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，&运算符给出指针本身的地址。
* 指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。
* 递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。
* 指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第一个运算对象，整数是第二个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。
* 递减指针：当然，出了递增指针还可以递减指针。
* 指针求差：可以计算两个指针的差集。通常，求差集的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。
* 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。

注意，这里的减法有两种。可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。

在递增或递减时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C只能保证指向数组任意元素的指针和指向数组后面第一个位置的指针是有效。但是，如果递增或递减一个指针后超出了这个范围，则是未定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置是有效的，也能解引用这样的越界指针。

说道注意事项，一定要牢记一点：千万不要解引用未初始化的指针。切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。

## 保护数组中的数据

### 对形式参数使用const

在K&R C的年代，避免类似错误的唯一方法是提高警惕。ANSI C提供了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。

使用const并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。这样使用const可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。一般而言，入股哦便携的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。

### const的其他内容

虽然用`#define`指令可以创建类似功能的符号常量，但是const的用法更加灵活。可以创建const数组、const指针和指向const的指针。

指向const的指针通常用于函数形参中，表明该函数不会使用指针改变数据。

关于指针赋值和const需要注意一些规则。首先，把const数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的。然而，只能把非const数据的地址赋给普通指针。

const还有其他的用法。可以声明并初始化一个不能指向别处的指针，关键是const的位置 ，可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。

在创建指针时还可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值。

## 指针和多维数组

