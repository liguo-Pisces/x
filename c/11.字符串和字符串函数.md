# 字符串和字符串函数

## 表示字符串和字符串I/O

字符串是以空字符（\0）结尾的char类型数组。

puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符。

### 在程序中定义字符串

#### 1. 字符串字面量（字符串常量）

用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\0字符，都是作为字符串储存的内存中。

从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。

如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\）。

字符串常量属于静态存储类型（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。

#### 2.字符串数组和初始化

定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。

在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）。所有未被使用的元素都被自动初始化为0（这里的0指的是char形式的空字符，不是数字字符0）。

通常，让编译器确定数组的大小很方便。

让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。在C99新增变长数组之前，数组的大小必须是整型常量，包括由整型常量组成的表达式。

字符数组名和其他数组名一样，是该数组首元素的地址。因此，假设有下面的初始化：

`char car[10] = "Tata";`

那么，以下表达式都为真：

`car == &car[0]、*car == 'T'、*(car + 1) == car[1] == 'a'`。

还可以使用指针表示法创建字符串。

#### 3.数组和指针

```c
const char *pt1 = "Something is pointing at me.";
const char ar1[] = "Something is pointing at me.";
```

数组形式和指针形式有何不同？数组形式（`ar1[]`）在计算机的内存中分配为一个内含29个元素的数组（没个元素对应一个字符，还加上一个末尾的空字符`'\0'`），每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中。注意，此时字符串有两个副本。一个是静态内存中的字符串字面量，另一个是储存在`ar1`数组中的字符串。

此后，编译器便把数组名`ar1`识别为该数组首元素地址（`&ar1[0]`）的别名。这里关键要理解，在数组形式中，`ar1`是地址常量。不能更改`ar1`，如果改变了`ar1`，则意味着改变了数组的存储位置（即地址）。可以进行类似`ar + 1`这样的操作，标识数组的下一个元素。但是不允许进行`++ar1`这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。

指针形式（`*pt1`）也使得编译器为字符串在静态存储区预留29个元素的空间。另外，一旦开始执行程序，它会为指针变量`pt1`留出一个储存位置，并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，`++pt1`将指向第2个字符（o）。

字符串字面量被视为const数据。由于`pt1`指向这个const数据，所以应该把`pt1`声明为指向const数据的指针。这意味着不能用`pt1`改变它所指向的数据，但是任然可以改变`pt1`的值（即，`pt1`指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。

总之，初始化数组把静态储存区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。

#### 4.数组和指针的区别

```c
char heart[] = "I love Tillie!";
const char *head = "I love Millie!";
```

数组名`heart`是常量，而指针名`head`是变量。

赋值运算符的左侧必须是变量（或概括地说是可修改的左值）。

数组的元素是变量（除非数组被声明为const），但是数组名不是变量。

建议在把指针初始化为字符串字面量时使用const限定符。

`const char *p1 = "Klingon";`

然而，把非const数组初始化为字符串字面量却不会导致类似的问题。因为数组获得的是原始字符串的副本。

总之，如果不修改字符串，不要用指针指向字符串字面量。

#### 5.字符串数组

指向字符串的指针数组和char类型数组的数组。

矩形数组和不规则数组。

如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维字符数组的效率高。但是，指针数组也有自身的缺点。指针指向的字符串字面量不能更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。

### 指针和字符串

字符串的绝大多数操作都是通过指针完成的。

## 字符串输入

如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。

### 分配空间

要做的第一件事是分配空间，以储存稍后读入的字符串。这意味着必须要为字符串分配足够的空间。不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间（计算机不会这样做，除非你编写一个处理这些任务的函数）。假设编写了如下代码：

```c
char *name;
scanf("%s", name);
```

虽然可能会通过编译（编译器很可能给出警告），但是在读入name时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的指针，name可能会指向任何地方。大多数程序员都认为出现这种情况很搞笑，但仅限于评价别人的程序时。

最简单的方法是，在声明时显式指明数组的大小：

`char name[81];`

现在name是一个已分配块（81字节）的地址。还有一种方法是使用C库函数来分配内存。

为字符串分配内存后，便可读入字符串。C库提供了许多读取字符串的函数。

### 不幸的gets()函数

在读取字符串时，scanf()和转换说明%s只能读取一个单词。可是在程序中经常要读取一整行输入，而不仅仅是一个单词。许多年前，gets()函数就用于处理这种情况。gets()函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个C字符串。它经常和puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。

gets()唯一的参数是words，它无法检查数组是否装得下输入行。数组名会被转换成该数组首元素的地址，因此，gets()函数只知道数组的开始处，并不知道数组中有多少个元素。

如果输入的字符串过长，会导致缓冲区溢出（buffer overflow），即多余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，就会导致程序异常中止；或者还有其他情况。

C11标准委员会采取了更强硬的态度，直接从标准中废除了gets()函数。

### gets()的代替品

#### 1.fgets()函数（和fputs()）

fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和gets()的区别如下。

* fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。
* 如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。
* fgets()函数的第3个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。

因为fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通常要与fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout（标准输出）作为该参数。

fputs()函数返回指向char的指针。如果一切进行顺利，该函数返回的地址与传入的第1个参数相同。但是，如果函数读到文件结尾，它将返回一个特殊的指针：空指针（null pointer）。该指针保证不会指向有效的数据，所以可用于标识符这种特殊情况。在代码中，可以用数字0来代替，不过在C语言中用宏NULL来代替更常见（如果在读入数据时出现某些错误，该函数也返回NULL）。

系统使用缓冲的I/O。这意味着用户在按下Return键之前，输入都被储存在临时存储区（即，缓冲区）中。按下Return键就在输入中增加了一个换行符，并把整行输入发送给fgets()。对于输出，fputs()把字符发送给另一个缓冲区，当发送换行符时，缓冲区的内容被发送至屏幕上。

空字符和空指针

空字符（或`'\0'`）是用于标记C字符串末尾的字符，其对应字符编码是0。由于其他字符编码不可能是0，所以不可能是字符串的一部分。

空指针（或NULL）有一个值，该值不会与任何数据的有效地址对应。通常，函数使用它返回一个有效地址表示某些特殊情况发生。

空字符是整数类型，而空指针是指针类型。两者有时容易混淆的原因是：它们都可以用数值0来表示。但是，从概念上看，两者是不同类型的0。另外，空字符是一个字符，占1字节；而空指针是一个地址，通常占用4字节。

#### 2.gets_s()函数

C11新增的gets_s()函数（可选）和fgets()类似，用一个参数限制读入的字符数。

gets_s()与fgets()的区别如下。

* gets_s()只从标准输入中读取数据，所以不需要第3个参数。
* 如果gets_s()读到换行符，会丢弃它而不是储存它。
* 如果gets_s()读到最大字符数都没有读到换行符，会执行以下几步。首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直到读到换行符或文件结尾，然后返回空指针。接着，调用依赖实现的“处理函数”，可能会中止或退出程序。

所以，当输入与预期不符时，gets_s()完全没有fgets()函数方便、灵活。也许这也是gets_s()只作为C库的可选扩展的原因之一。鉴于此，fgets()通常是处理类似情况的最佳选择。

### scanf()函数

scanf()和gets()或fgets()的区别在于它们如何确定字符串的末尾：scanf()更像是“获取单词”函数，而不是“获取字符串”函数；如果预留的存储区装得下输入行，gets()和fgets()会读取第1个换行符之前所有的字符。scanf()函数有两种方法确定输入结束。无论哪种方法，都从第1个非空白字符作为字符串的开始。如果使用%s转换说明，以下一个空白字符（空行、空格、制表符或换行符）作为字符串的结束（字符串不包括空白字符）。如果指定了字符宽度，如%10s，那么scanf()将读取10个字符或读到第1个空白字符停止（先满足的条件即是结束输入的条件）。

scanf()函数返回一个整数值，该值等于scanf()成功读取的项数或EOF（读到文件结尾时返回EOF）。

根据输入数据的性质，用fgets()读取从键盘输入的数据更合适。scanf()的典型用法是读取并转换混合数据类型为某种标准形式。

如果输入行的内容过长，scanf()也会导致数据溢出。不过，在%s转换说明中使用字段宽度可防止溢出。

## 字符串输出

### puts()函数

puts()函数很容易使用，只需把字符串的地址作为参数传递给它即可。

puts()在显示字符串时会自动在其末尾添加一个换行符。

puts()如何知道在何处停止？该函数在 遇到空字符时就停止输出，所以必须确保有空字符。

### fputs()函数

fputs()函数是puts()针对文件定制的版本。它们的区别如下。

* fputs()函数的第2个参数指明要写入数据的文件。
* 与puts()不同，fputs()不会在输出的末尾添加换行符。

注意，gets()丢弃输入中的换行符，但是puts()在输出中添加换行符。另一方面，fgets()保留输入中的换行符，fputs()不在输出中添加换行符。

### printf()函数

printf()函数用起来没有puts()函数那么方便，但是它更加多才多艺，因为它可以格式化不同的数据类型。

## 自定义输入/输出函数

不一定非要使用C库中的标准函数，如果无法使用这些函数或者不想用它们，完全可以在getchar()和putchar()的基础上自定义所需的函数。

许多C程序员会在while循环中使用下面的测试条件：

`while (*string)`

当string指向空字符串时，\*string的值是0，即测试条件为假，while循环结束。这种方法比上面两种方法简介。但是，如果不熟悉C语言，可能觉察不出来。这种处理方法很普遍，作为C程序员应该熟悉这种写法。

## 字符串函数

### strlen()函数

strlen()函数用于统计字符串的长度。

一些ANSI之前的系统使用strings.h头文件，而有些系统可能根本没有字符串头文件。

string.h头文件中包含了C字符串函数系列的原型。

### strcat()函数

strcat()（用于拼接字符串）函数接受两个字符串作为参数。该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。strcat()函数的类型是char *（即，指向char的指针）。strcat()函数返回第1个参数，即拼接第2个字符串后的第1个字符串的地址。

### strncat()函数

strcat()函数无法检查第1个数组是否能容纳第2个字符串。如果分配给第1个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。用strncat()，该函数的第3个参数指定了最大添加字符数。

strcat()和gets()类似，也会导致缓冲区溢出。为什么C11标准不废弃strcat()，只留下strncat()？C语言相信程序员，因此程序员有责任确保strcat()的使用安全。

### strcmp()函数

该函数通过比较运算符来比较字符串，就像比较数字一样。如果两个字符串参数相同，该函数就返回0，否则返回非零值。

