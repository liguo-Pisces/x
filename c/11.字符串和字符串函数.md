# 字符串和字符串函数

## 表示字符串和字符串I/O

字符串是以空字符（\0）结尾的char类型数组。

puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符。

### 在程序中定义字符串

#### 1. 字符串字面量（字符串常量）

用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\0字符，都是作为字符串储存的内存中。

从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。

如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\）。

字符串常量属于静态存储类型（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。

#### 2.字符串数组和初始化

定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。

在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）。所有未被使用的元素都被自动初始化为0（这里的0指的是char形式的空字符，不是数字字符0）。

通常，让编译器确定数组的大小很方便。

让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。在C99新增变长数组之前，数组的大小必须是整型常量，包括由整型常量组成的表达式。

字符数组名和其他数组名一样，是该数组首元素的地址。因此，假设有下面的初始化：

`char car[10] = "Tata";`

那么，以下表达式都为真：

`car == &car[0]、*car == 'T'、*(car + 1) == car[1] == 'a'`。

还可以使用指针表示法创建字符串。

#### 3.数组和指针

```c
const char *pt1 = "Something is pointing at me.";
const char ar1[] = "Something is pointing at me.";
```

数组形式和指针形式有何不同？数组形式（`ar1[]`）在计算机的内存中分配为一个内含29个元素的数组（没个元素对应一个字符，还加上一个末尾的空字符`'\0'`），每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中。注意，此时字符串有两个副本。一个是静态内存中的字符串字面量，另一个是储存在`ar1`数组中的字符串。

此后，编译器便把数组名`ar1`识别为该数组首元素地址（`&ar1[0]`）的别名。这里关键要理解，在数组形式中，`ar1`是地址常量。不能更改`ar1`，如果改变了`ar1`，则意味着改变了数组的存储位置（即地址）。可以进行类似`ar + 1`这样的操作，标识数组的下一个元素。但是不允许进行`++ar1`这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。

指针形式（`*pt1`）也使得编译器为字符串在静态存储区预留29个元素的空间。另外，一旦开始执行程序，它会为指针变量`pt1`留出一个储存位置，并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，`++pt1`将指向第2个字符（o）。

字符串字面量被视为const数据。由于`pt1`指向这个const数据，所以应该把`pt1`声明为指向const数据的指针。这意味着不能用`pt1`改变它所指向的数据，但是任然可以改变`pt1`的值（即，`pt1`指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。

总之，初始化数组把静态储存区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。

#### 4.数组和指针的区别

```c
char heart[] = "I love Tillie!";
const char *head = "I love Millie!";
```

数组名`heart`是常量，而指针名`head`是变量。

赋值运算符的左侧必须是变量（或概括地说是可修改的左值）。

数组的元素是变量（除非数组被声明为const），但是数组名不是变量。

建议在把指针初始化为字符串字面量时使用const限定符。

`const char *p1 = "Klingon";`

然而，把非const数组初始化为字符串字面量却不会导致类似的问题。因为数组获得的是原始字符串的副本。

总之，如果不修改字符串，不要用指针指向字符串字面量。

#### 5.字符串数组

指向字符串的指针数组和char类型数组的数组。

矩形数组和不规则数组。

如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维字符数组的效率高。但是，指针数组也有自身的缺点。指针指向的字符串字面量不能更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。

### 指针和字符串

字符串的绝大多数操作都是通过指针完成的。

## 字符串输入

如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。

### 分配空间

要做的第一件事是分配空间，以储存稍后读入的字符串。这意味着必须要为字符串分配足够的空间。不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间（计算机不会这样做，除非你编写一个处理这些任务的函数）。假设编写了如下代码：

```c
char *name;
scanf("%s", name);
```

虽然可能会通过编译（编译器很可能给出警告），但是在读入name时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的指针，name可能会指向任何地方。大多数程序员都认为出现这种情况很搞笑，但仅限于评价别人的程序时。

最简单的方法是，在声明时显式指明数组的大小：

`char name[81];`

现在name是一个已分配块（81字节）的地址。还有一种方法是使用C库函数来分配内存。

为字符串分配内存后，便可读入字符串。C库提供了许多读取字符串的函数。

### 不幸的gets()函数

在读取字符串时，scanf()和转换说明%s只能读取一个单词。可是在程序中经常要读取一整行输入，而不仅仅是一个单词。许多年前，gets()函数就用于处理这种情况。gets()函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个C字符串。它经常和puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。

gets()唯一的参数是words，它无法检查数组是否装得下输入行。数组名会被转换成该数组首元素的地址，因此，gets()函数只知道数组的开始处，并不知道数组中有多少个元素。

如果输入的字符串过长，会导致缓冲区溢出（buffer overflow），即多余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，就会导致程序异常中止；或者还有其他情况。

C11标准委员会采取了更强硬的态度，直接从标准中废除了gets()函数。

### gets()的代替品

#### 1.fgets()函数（和fputs()）

fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和gets()的区别如下。

* fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。
* 如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。
* fgets()函数的第3个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。

因为fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通常要与fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout（标准输出）作为该参数。

fputs()函数返回指向char的指针。如果一切进行顺利，该函数返回的地址与传入的第1个参数相同。但是，如果函数读到文件结尾，它将返回一个特殊的指针：空指针（null pointer）。该指针保证不会指向有效的数据，所以可用于标识符这种特殊情况。在代码中，可以用数字0来代替，不过在C语言中用宏NULL来代替更常见（如果在读入数据时出现某些错误，该函数也返回NULL）。

系统使用缓冲的I/O。这意味着用户在按下Return键之前，输入都被储存在临时存储区（即，缓冲区）中。按下Return键就在输入中增加了一个换行符，并把整行输入发送给fgets()。对于输出，fputs()把字符发送给另一个缓冲区，当发送换行符时，缓冲区的内容被发送至屏幕上。

空字符和空指针

空字符（或`'\0'`）是用于标记C字符串末尾的字符，其对应字符编码是0。由于其他字符编码不可能是0，所以不可能是字符串的一部分。

空指针（或NULL）有一个值，该值不会与任何数据的有效地址对应。通常，函数使用它返回一个有效地址表示某些特殊情况发生。

空字符是整数类型，而空指针是指针类型。两者有时容易混淆的原因是：它们都可以用数值0来表示。但是，从概念上看，两者是不同类型的0。另外，空字符是一个字符，占1字节；而空指针是一个地址，通常占用4字节。

#### 2.gets_s()函数

C11新增的gets_s()函数（可选）和fgets()类似，用一个参数限制读入的字符数。

gets_s()与fgets()的区别如下。

* gets_s()只从标准输入中读取数据，所以不需要第3个参数。
* 如果gets_s()读到换行符，会丢弃它而不是储存它。
* 如果gets_s()读到最大字符数都没有读到换行符，会执行以下几步。首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直到读到换行符或文件结尾，然后返回空指针。接着，调用依赖实现的“处理函数”，可能会中止或退出程序。

所以，当输入与预期不符时，gets_s()完全没有fgets()函数方便、灵活。也许这也是gets_s()只作为C库的可选扩展的原因之一。鉴于此，fgets()通常是处理类似情况的最佳选择。

### scanf()函数

scanf()和gets()或fgets()的区别在于它们如何确定字符串的末尾：scanf()更像是“获取单词”函数，而不是“获取字符串”函数；如果预留的存储区装得下输入行，gets()和fgets()会读取第1个换行符之前所有的字符。scanf()函数有两种方法确定输入结束。无论哪种方法，都从第1个非空白字符作为字符串的开始。如果使用%s转换说明，以下一个空白字符（空行、空格、制表符或换行符）作为字符串的结束（字符串不包括空白字符）。如果指定了字符宽度，如%10s，那么scanf()将读取10个字符或读到第1个空白字符停止（先满足的条件即是结束输入的条件）。

scanf()函数返回一个整数值，该值等于scanf()成功读取的项数或EOF（读到文件结尾时返回EOF）。

根据输入数据的性质，用fgets()读取从键盘输入的数据更合适。scanf()的典型用法是读取并转换混合数据类型为某种标准形式。

如果输入行的内容过长，scanf()也会导致数据溢出。不过，在%s转换说明中使用字段宽度可防止溢出。

## 字符串输出

### puts()函数

puts()函数很容易使用，只需把字符串的地址作为参数传递给它即可。

puts()在显示字符串时会自动在其末尾添加一个换行符。

puts()如何知道在何处停止？该函数在 遇到空字符时就停止输出，所以必须确保有空字符。

### fputs()函数

fputs()函数是puts()针对文件定制的版本。它们的区别如下。

* fputs()函数的第2个参数指明要写入数据的文件。
* 与puts()不同，fputs()不会在输出的末尾添加换行符。

注意，gets()丢弃输入中的换行符，但是puts()在输出中添加换行符。另一方面，fgets()保留输入中的换行符，fputs()不在输出中添加换行符。

### printf()函数

printf()函数用起来没有puts()函数那么方便，但是它更加多才多艺，因为它可以格式化不同的数据类型。

## 自定义输入/输出函数

不一定非要使用C库中的标准函数，如果无法使用这些函数或者不想用它们，完全可以在getchar()和putchar()的基础上自定义所需的函数。

许多C程序员会在while循环中使用下面的测试条件：

`while (*string)`

当string指向空字符串时，\*string的值是0，即测试条件为假，while循环结束。这种方法比上面两种方法简介。但是，如果不熟悉C语言，可能觉察不出来。这种处理方法很普遍，作为C程序员应该熟悉这种写法。

## 字符串函数

### strlen()函数

strlen()函数用于统计字符串的长度。

一些ANSI之前的系统使用strings.h头文件，而有些系统可能根本没有字符串头文件。

string.h头文件中包含了C字符串函数系列的原型。

### strcat()函数

strcat()（用于拼接字符串）函数接受两个字符串作为参数。该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。strcat()函数的类型是char *（即，指向char的指针）。strcat()函数返回第1个参数，即拼接第2个字符串后的第1个字符串的地址。

### strncat()函数

strcat()函数无法检查第1个数组是否能容纳第2个字符串。如果分配给第1个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。用strncat()，该函数的第3个参数指定了最大添加字符数。

strcat()和gets()类似，也会导致缓冲区溢出。为什么C11标准不废弃strcat()，只留下strncat()？C语言相信程序员，因此程序员有责任确保strcat()的使用安全。

### strcmp()函数

该函数通过比较运算符来比较字符串，就像比较数字一样。如果两个字符串参数相同，该函数就返回0，否则返回非零值。

strcmp()函数比较的是字符串，不是整个数组，这是非常好的功能。

strcmp()比较所有的字符，不只是字母。所以，与其说该函数按字母顺序进行比较，不如说是按机器排序序列（machine collating sequence）进行比较，即根据字符的数值进行比较（通常都使用ASCII值）。

大多数情况下，strcmp()返回的具体值并不重要，我们只在意该值是0还是非0（即，比较的两个字符串是否相等）。或者按字母排序字符串，在这种情况下，需要知道比较的结果是为正、为负还是为0。

strcmp()函数比较的是字符串，不是字符，所以其参数应该是字符串，而不是字符。但是，char类型实际上是整数类型，所以可以使用关系运算符来比较字符。

strncmp()函数

strncmp()函数比较字符串中的字符，知道发现不同的字符为止，这一过程可能会持续到字符串的末尾。而strncmp()函数在比较两个字符串时，可以比较到字符不同的地方，也可以值比较第3个参数指定的字符数。

### strcpy()和strncpy()函数

如果希望拷贝整个字符串，要使用strcpy()函数。

strcpy()第2个参数指向的字符串被拷贝至第1个参数指向的数组中。拷贝出来的字符串被称为目标字符串，最初的字符串被称为源字符串。参考赋值表达式语句，很容易记住strcpy()参数的顺序，即第1个目标字符串，第2个源字符串。

程序员有责任确保目标数组有足够的空间容纳源字符串的副本。

总之，strcpy()接受两个字符串指针作为参数，可以把指向源字符串的第2个指针声明为指针、数组名或字符串常量；而指向源字符串副本的第1个指针应该指向一个数据对象（如，数组），且该对象有足够的空间储存源字符串的副本。记住，声明数组将分配储存数据的空间，而声明指针只分配储存一个地址的空间。

strcpy()函数还有两个有用的属性。第一，strcpy()的返回类型是char *，该函数返回的是第1个参数的值，即一个字符的地址。第二，第1个参数不必指向数组的开始。这个属性可用于拷贝数组的一部分。

strcpy()和strcat()都有同样的问题，它们都不能检查目标空间是否能容纳源字符串的副本。拷贝字符串用strncpy()更安全，该函数的第3个参数指明可拷贝的最大字符数。

### sprintf()函数

该函数和printf()类似，但是它是把数据写入字符串，而不是打印在显示器上。因此，该函数可以把多个元素组合成一个字符串。sprintf()的第1个参数是目标字符串的地址。其余参数和printf()相同，即格式字符串和待写入项的列表。

### 其他字符串函数

ANSI C库有20多个用于处理字符串的函数，下面总结了一些常用的函数。

* `char *strcpy(char *restrict s1, const char * restrict s2);`
* `char *strncpy(char *restrict s1, const char *restrict s1, size_t n);`
* `char *strcat(char *restrict s1, const char *restrict s2);`
* `char *strncat(char *restrict s1, const char *restrict s2, size_t n);`
* `int strcmp(const char *s1, const char *s2);`
* `int strncmp(const char *s1, const char *s2, size_t n);`
* `char *strchr(const char *s, int c);`
* `char *strpbrk(const char *s1, const char *s2);`
* `char *strrchr(const char *s, int c);`
* `char *strstr(const char *s1, const char *s2);`
* `size_t strlen(const char *s);`

## 字符串示例：字符串排序

选择排序算法（selection sort algorithm）

## 命令行参数

命令行（command line）

命令行参数（command-line argument）

C编译器允许main()没有参数或者有两个参数。main()有两个参数时，第1个参数时命令行中的字符串数量。过去，这个int类型的参数被称为argc（表示参数计数（argument count））。系统用空格表示一个字符串的结束和下一个字符串的开始。该程序把命令行字符串储存在内存中，并把每个字符串的地址储存在指针数组中。而该数组的地址则被储存在main()的第2个参数中。按照惯例，这个指向指针的指针称为argv（表示参数值（argument value））。如果系统允许，就把程序本身的名称赋给argv[0]，然后把随后的第1个字符串赋给argv[1]，以此类推。

## 把字符串转换为数字

atoi()函数用于把字母数字转换成整数。stdlib.h头文件中包含了atoi()函数的原型。

ANSI C还提供了一套更智能的函数：strtol()等，这些函数的智能之处在于识别和报告字符串中的首字符是否是数字。

许多实现使用itoa()和ftoa()函数分别把整数和浮点数转换成字符串。但是这两个函数并不是C标准库的成员，可以用sprintf()函数代替它们，因为sprintf()的兼容性更好。

## 关键概念

许多程序都要处理文本数据。一个程序可能要求用户输入姓名、公司列表、地址、一种蕨类植物的学名、音乐剧的演员等。毕竟，我们用言语与现实世界互动，使用文本的例子不计其数。C程序通过字符串的方式来处理它们。

字符串，无论是字符数组、指针还是字符串常量标识，都储存为包含字符编码的一系列字节，并以空字符串结尾。C提供库函数处理字符串，查找字符串并分析它们。尤其要牢记，应该使用strcmp()来代替关系运算符，当比较字符串时，应该使用strcpy()或strncpy()代替赋值运算符把字符串赋给字符数组。

## 本章小结

C字符串是一系列char类型的字符，以空字符串（`\0`）结尾。字符串可以储存在字符数组中。字符串还可以用字符串常量来表示，里面都是字符，括在双引号中（空字符除外）。编译器提供空字符。因此，`"joy"`被储存为4个字符`j`、`o`、`y`和`\0`。strlen()函数可以统计字符串的长度，空字符不计算在内。

字符串常量也叫作字符串 - 字面量，可用于初始化字符数组。为了容纳末尾的空字符，数组大小应该至少比容纳的数组长度多1。也可以用字符串常量初始化指向char的指针。

函数使用指向字符串首字符的指针来表示待处理的字符串。通常，对应的实际参数是数组名、指针变量或双括号括起来的字符串。无论是哪种情况，传递的都是首字符的地址。一般而言，没必要传递字符串的长度，因为函数可以通过末尾的空字符确定字符串的结束。

fgets()函数获取一行输入，puts()和fputs()函数显示一行输出。它们都是stdio.h头文件中的函数，用于代替已被弃用的gets()。

C库中有多个字符串处理函数。在ANSI C中，这些函数都声明在string.h文件中。C库中还有许多字符串处理函数，声明在ctype.h文件中。

给main()函数提供两个合适的形式参数，可以让程序访问命令行参数。第1个参数通常是int类型的argc，其值是命令行的单词数量。第2个参数通常是一个指向数组的指针argv，数组内含指向char的指针。每个指向char的指针都指向一个命令行参数字符串，`argv[0]`指向命令名称，`argv[1]`指向第1个命令行参数，以此类推。

atoi()、atol()和atof()函数把字符串形式的数字分别转换成int、long和double类型的数字。strtol()、strtoul()和strtod()函数把字符串形式的数字分别转换成long、unsigned long和double类型的数字。



