# 字符串和字符串函数

## 表示字符串和字符串I/O

字符串是以空字符（\0）结尾的char类型数组。

puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符。

### 在程序中定义字符串

#### 1. 字符串字面量（字符串常量）

用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\0字符，都是作为字符串储存的内存中。

从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。

如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\）。

字符串常量属于静态存储类型（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。

#### 2.字符串数组和初始化

定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。

在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）。所有未被使用的元素都被自动初始化为0（这里的0指的是char形式的空字符，不是数字字符0）。

通常，让编译器确定数组的大小很方便。

让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。在C99新增变长数组之前，数组的大小必须是整型常量，包括由整型常量组成的表达式。

字符数组名和其他数组名一样，是该数组首元素的地址。因此，假设有下面的初始化：

`char car[10] = "Tata";`

那么，以下表达式都为真：

`car == &car[0]、*car == 'T'、*(car + 1) == car[1] == 'a'`。

还可以使用指针表示法创建字符串。

#### 3.数组和指针

```c
const char *pt1 = "Something is pointing at me.";
const char ar1[] = "Something is pointing at me.";
```

数组形式和指针形式有何不同？数组形式（`ar1[]`）在计算机的内存中分配为一个内含29个元素的数组（没个元素对应一个字符，还加上一个末尾的空字符`'\0'`），每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中。注意，此时字符串有两个副本。一个是静态内存中的字符串字面量，另一个是储存在`ar1`数组中的字符串。

此后，编译器便把数组名`ar1`识别为该数组首元素地址（`&ar1[0]`）的别名。这里关键要理解，在数组形式中，`ar1`是地址常量。不能更改`ar1`，如果改变了`ar1`，则意味着改变了数组的存储位置（即地址）。可以进行类似`ar + 1`这样的操作，标识数组的下一个元素。但是不允许进行`++ar1`这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。

指针形式（`*pt1`）也使得编译器为字符串在静态存储区预留29个元素的空间。另外，一旦开始执行程序，它会为指针变量`pt1`留出一个储存位置，并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，`++pt1`将指向第2个字符（o）。

字符串字面量被视为const数据。由于`pt1`指向这个const数据，所以应该把`pt1`声明为指向const数据的指针。这意味着不能用`pt1`改变它所指向的数据，但是任然可以改变`pt1`的值（即，`pt1`指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。

总之，初始化数组把静态储存区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。

#### 4.数组和指针的区别

